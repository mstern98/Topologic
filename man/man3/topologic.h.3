.TH "include/topologic.h" 3 "Mon Mar 15 2021" "Version 1.0.6" "Topologic" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/topologic.h
.SH SYNOPSIS
.br
.PP
\fC#include '\&./header\&.h'\fP
.br
\fC#include '\&./stack\&.h'\fP
.br
\fC#include '\&./AVL\&.h'\fP
.br
\fC#include '\&./edge\&.h'\fP
.br
\fC#include '\&./vertex\&.h'\fP
.br
\fC#include '\&./request\&.h'\fP
.br
\fC#include '\&./graph\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBfireable\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPTHREAD_SLEEP_TIME\fP   50"
.br
.ti -1c
.RI "#define \fB_GNU_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBTOPOLOGIC_DEBUG\fP   0"
.br
.ti -1c
.RI "#define \fBtopologic_debug\fP(fmt, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBMAX_LOOPS\fP   100"
.br
.ti -1c
.RI "#define \fBGRAPH_INIT\fP()   \fBgraph_init\fP(\-1, \fBSTART_STOP\fP, \fBMAX_LOOPS\fP, \fBVERTICES\fP | \fBEDGES\fP | \fBFUNCTIONS\fP | \fBGLOBALS\fP, \fBSINGLE\fP, \fBCONTINUE\fP)"
.br
.ti -1c
.RI "#define \fBCREATE_VERTEX\fP(\fBgraph\fP,  f,  id)   \fBcreate_vertex\fP(\fBgraph\fP, f, id, NULL, PROTECT_B_VARS)"
.br
.ti -1c
.RI "#define \fBCREATE_VERTEX_GLBL\fP(\fBgraph\fP,  f,  id,  glbl)   \fBcreate_vertex\fP(\fBgraph\fP, f, id, glbl, PROTECT_B_VARS)"
.br
.ti -1c
.RI "#define \fBCREATE_EDGE\fP(a,  b,  f)   \fBcreate_edge\fP(a, b, f, NULL)"
.br
.ti -1c
.RI "#define \fBCREATE_NULL_BI_EDGE\fP(a,  b,  f)   \fBcreate_bi_edge\fP(a, b, f, NULL, NULL, NULL)"
.br
.ti -1c
.RI "#define \fBCREATE_BI_EDGE\fP(a,  b,  f,  a_to_b,  b_to_a)   \fBcreate_bi_edge\fP(a, b, f, NULL, a_to_b, b_to_a)"
.br
.ti -1c
.RI "#define \fBMODIFY_VERTEX\fP(\fBvertex\fP,  f)   \fBmodify_vertex\fP(\fBvertex\fP, f, NULL)"
.br
.ti -1c
.RI "#define \fBMODIFY_VERTEX_GLOBALS\fP(\fBvertex\fP,  glbl)   \fBmodify_vertex\fP(\fBvertex\fP, NULL, glbl)"
.br
.ti -1c
.RI "#define \fBMODIFY_EDGE\fP(a,  b,  f)   \fBmodify_edge\fP(a, b, f, NULL)"
.br
.ti -1c
.RI "#define \fBMODIFY_EDGE_GLOBALS\fP(a,  b,  glbl)   \fBmodify_edge\fP(a, b, NULL, glbl)"
.br
.ti -1c
.RI "#define \fBMODIFY_BI_EDGE\fP(a,  b,  f)   \fBmodify_bi_edge\fP(a, b, f, NULL)"
.br
.ti -1c
.RI "#define \fBMODIFY_BI_EDGE_GLOBALS\fP(a,  b,  glbl)   \fBmodify_bi_edge\fP(a, b, NULL, glbl)"
.br
.ti -1c
.RI "#define \fBCREATE_REQUEST\fP(\fBrequest\fP,  args)   \fBcreate_request\fP(\fBrequest\fP, args, NULL)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBfire_pthread\fP (void *vargp)"
.br
.ti -1c
.RI "struct \fBgraph\fP * \fBgraph_init\fP (int max_state_changes, int snapshot_timestamp, int max_loop, unsigned int lvl_verbose, enum \fBCONTEXT\fP context, enum \fBMEM_OPTION\fP mem_option)"
.br
.ti -1c
.RI "struct \fBvertex\fP * \fBcreate_vertex\fP (struct \fBgraph\fP *\fBgraph\fP, void(*f)(struct \fBgraph\fP *, struct \fBvertex_result\fP *, void *, void *), int id, void *glbl)"
.br
.ti -1c
.RI "struct \fBedge\fP * \fBcreate_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b, int(*f)(void *, void *, const void *const, const void *const), void *glbl)"
.br
.ti -1c
.RI "int \fBcreate_bi_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b, int(*f)(void *, void *, const void *const, const void *const), void *glbl, struct \fBedge\fP **edge_a_to_b, struct \fBedge\fP **edge_b_to_a)"
.br
.ti -1c
.RI "int \fBremove_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b)"
.br
.ti -1c
.RI "int \fBremove_edge_id\fP (struct \fBvertex\fP *a, int id)"
.br
.ti -1c
.RI "int \fBremove_bi_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b)"
.br
.ti -1c
.RI "int \fBremove_vertex\fP (struct \fBgraph\fP *\fBgraph\fP, struct \fBvertex\fP *\fBvertex\fP)"
.br
.ti -1c
.RI "int \fBremove_vertex_id\fP (struct \fBgraph\fP *\fBgraph\fP, int id)"
.br
.ti -1c
.RI "int \fBmodify_vertex\fP (struct \fBvertex\fP *\fBvertex\fP, void(*f)(struct \fBgraph\fP *, struct \fBvertex_result\fP *, void *, void *), void *glbl)"
.br
.ti -1c
.RI "int \fBmodify_shared_edge_vars\fP (struct \fBvertex\fP *\fBvertex\fP, void *edge_vars)"
.br
.ti -1c
.RI "int \fBmodify_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b, int(*f)(void *, void *, const void *const, const void *const), void *glbl)"
.br
.ti -1c
.RI "int \fBmodify_bi_edge\fP (struct \fBvertex\fP *a, struct \fBvertex\fP *b, int(*f)(void *, void *, const void *const, const void *const), void *glbl)"
.br
.ti -1c
.RI "int \fBfire\fP (struct \fBgraph\fP *\fBgraph\fP, struct \fBvertex\fP *\fBvertex\fP, struct \fBvertex_result\fP *args, enum \fBSTATES\fP color, int iloop)"
.br
.ti -1c
.RI "int \fBswitch_vertex\fP (struct \fBgraph\fP *\fBgraph\fP, struct \fBvertex\fP *\fBvertex\fP, struct \fBvertex_result\fP *args, enum \fBSTATES\fP color, int iloop)"
.br
.ti -1c
.RI "int \fBstart_set\fP (struct \fBgraph\fP *\fBgraph\fP, int id[], int num_vertices)"
.br
.ti -1c
.RI "int \fBsubmit_request\fP (struct \fBgraph\fP *, struct \fBrequest\fP *\fBrequest\fP)"
.br
.ti -1c
.RI "struct \fBrequest\fP * \fBcreate_request\fP (enum \fBREQUESTS\fP \fBrequest\fP, void *args, void(*f)(void *))"
.br
.ti -1c
.RI "int \fBprocess_requests\fP (struct \fBgraph\fP *\fBgraph\fP)"
.br
.ti -1c
.RI "int \fBrun\fP (struct \fBgraph\fP *\fBgraph\fP, struct \fBvertex_result\fP **vertex_args)"
.br
.ti -1c
.RI "int \fBresume_graph\fP (struct \fBgraph\fP *\fBgraph\fP)"
.br
.ti -1c
.RI "int \fBpause_graph\fP (struct \fBgraph\fP *\fBgraph\fP)"
.br
.ti -1c
.RI "void \fBprint_graph\fP (struct \fBgraph\fP *\fBgraph\fP)"
.br
.ti -1c
.RI "struct \fBgraph\fP * \fBparse_json\fP (const char *path)"
.br
.ti -1c
.RI "int \fBdestroy_graph\fP (struct \fBgraph\fP *\fBgraph\fP)"
.br
.ti -1c
.RI "int \fBdestroy_request\fP (struct \fBrequest\fP *\fBrequest\fP)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define _GNU_SOURCE"

.SS "#define CREATE_BI_EDGE(a, b, f, a_to_b, b_to_a)   \fBcreate_bi_edge\fP(a, b, f, NULL, a_to_b, b_to_a)"

.SS "#define CREATE_EDGE(a, b, f)   \fBcreate_edge\fP(a, b, f, NULL)"

.SS "#define CREATE_NULL_BI_EDGE(a, b, f)   \fBcreate_bi_edge\fP(a, b, f, NULL, NULL, NULL)"

.SS "#define CREATE_REQUEST(\fBrequest\fP, args)   \fBcreate_request\fP(\fBrequest\fP, args, NULL)"

.SS "#define CREATE_VERTEX(\fBgraph\fP, f, id)   \fBcreate_vertex\fP(\fBgraph\fP, f, id, NULL, PROTECT_B_VARS)"

.SS "#define CREATE_VERTEX_GLBL(\fBgraph\fP, f, id, glbl)   \fBcreate_vertex\fP(\fBgraph\fP, f, id, glbl, PROTECT_B_VARS)"

.SS "#define GRAPH_INIT()   \fBgraph_init\fP(\-1, \fBSTART_STOP\fP, \fBMAX_LOOPS\fP, \fBVERTICES\fP | \fBEDGES\fP | \fBFUNCTIONS\fP | \fBGLOBALS\fP, \fBSINGLE\fP, \fBCONTINUE\fP)"

.SS "#define MAX_LOOPS   100"

.SS "#define MODIFY_BI_EDGE(a, b, f)   \fBmodify_bi_edge\fP(a, b, f, NULL)"

.SS "#define MODIFY_BI_EDGE_GLOBALS(a, b, glbl)   \fBmodify_bi_edge\fP(a, b, NULL, glbl)"

.SS "#define MODIFY_EDGE(a, b, f)   \fBmodify_edge\fP(a, b, f, NULL)"

.SS "#define MODIFY_EDGE_GLOBALS(a, b, glbl)   \fBmodify_edge\fP(a, b, NULL, glbl)"

.SS "#define MODIFY_VERTEX(\fBvertex\fP, f)   \fBmodify_vertex\fP(\fBvertex\fP, f, NULL)"

.SS "#define MODIFY_VERTEX_GLOBALS(\fBvertex\fP, glbl)   \fBmodify_vertex\fP(\fBvertex\fP, NULL, glbl)"

.SS "#define PTHREAD_SLEEP_TIME   50"

.SS "#define TOPOLOGIC_DEBUG   0"

.SS "#define topologic_debug(fmt,  \&.\&.\&.)"
\fBValue:\fP
.PP
.nf
                                                                   do {if (TOPOLOGIC_DEBUG) fprintf(stderr, "%s:%s:%s:%d:%s(): " fmt "\n", __DATE__, __TIME__, \
                                                                   __FILE__,  __LINE__, __func__, __VA_ARGS__); } while (0)
.fi
.SH "Function Documentation"
.PP 
.SS "int create_bi_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b, int(*)(void *, void *, const void *const, const void *const) f, void * glbl, struct \fBedge\fP ** edge_a_to_b, struct \fBedge\fP ** edge_b_to_a)"
@RETURNS 0 for success; -1 for fail See create_edge Will create an bidirectional edge between vertex a and b with some criteria determined by the function f\&. Will store the edges in edge_a and edge_b\&. If edge_a_to_b or edge_b_to_a is NULL it will not\&. 
.PP
References edge::a, edge::b, BI_EDGE, edge::bi_edge, edge::bi_edge_lock, vertex::context, create_edge(), edge::edge_type, edge::f, edge::glbl, remove_edge(), SINGLE, and topologic_debug\&.
.PP
Referenced by procces_request(), and test_graph_add_bi_edge()\&.
.SS "struct \fBedge\fP* create_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b, int(*)(void *, void *, const void *const, const void *const) f, void * glbl)"
@PARAM a: A vertex @PARAM b: Another vertex (can be 'a') @PARAM f: a function @PARAM glbl: global variables @RETURN the edge connecting a to b Will create an edge from vertex a to b with some criteria determined by the function f\&. NOTE: NULL glbl will mean no global variables\&. f cannot be NULL\&. 
.PP
References edge::a, edge::a_vars, edge::b, edge::b_vars, edge::bi_edge, vertex::context, EDGE, shared_edge::edge_data, vertex::edge_tree, edge::edge_type, edge::f, find(), edge::glbl, edge::id, vertex::id, insert(), vertex::joining_vertices, vertex::lock, remove_edge(), remove_ID(), SELF_EDGE, vertex::shared, SINGLE, SWITCH, and topologic_debug\&.
.PP
Referenced by create_bi_edge(), procces_request(), and test_graph_add_edge()\&.
.SS "struct \fBrequest\fP* create_request (enum \fBREQUESTS\fP request, void * args, void(*)(void *) f)"
@PARAM request: the desired request @PARAM args: the arguments needed for f @PARAM f: the function of the request @RETURN the request or NULL if it fails Creates a request structure to be called later 
.PP
References request::args, CREAT_BI_EDGE, CREAT_EDGE, CREAT_VERTEX, DESTROY_BI_EDGE, DESTROY_EDGE, DESTROY_EDGE_BY_ID, DESTROY_VERTEX, DESTROY_VERTEX_BY_ID, request::f, GENERIC, MOD_BI_EDGE, MOD_EDGE, MOD_EDGE_VARS, MOD_VERTEX, request::request, and topologic_debug\&.
.PP
Referenced by init(), setEdge(), setupSelfEdge(), setupVertex(), test_submit_request(), and vertexFunction()\&.
.SS "struct \fBvertex\fP* create_vertex (struct \fBgraph\fP * graph, void(*)(struct \fBgraph\fP *, struct \fBvertex_result\fP *, void *, void *) f, int id, void * glbl)"
@PARAM graph: the graph @PARAM f: a function @PARAM id: vertex id to be used: MUST BE UNIQUE @PARAM glbl: global variables @RETURN vertex: a vertex to be used in a graph On creation a process will be spawned for the vertex The vertex will compute function f when called NOTE: NULL glbl will mean no global variables\&. f cannot be NULL\&. 
.PP
References graph::context, vertex::context, destroy_avl(), vertex::edge_tree, vertex::f, vertex::glbl, vertex::id, init_avl(), insert(), vertex::is_active, vertex::joining_vertices, graph::lock, vertex::lock, vertex::shared, SINGLE, topologic_debug, shared_edge::vertex_data, and graph::vertices\&.
.PP
Referenced by procces_request(), and test_graph_insert_vertex()\&.
.SS "int destroy_graph (struct \fBgraph\fP * graph)"
@PARAM graph: the graph @RETURN -1 for fail; 0 for success Destroys and frees the graph 
.PP
References graph::black_fire, graph::black_locked, graph::black_vertex_count, graph::color_lock, graph::context, destroy_graph_avl(), destroy_graph_stack(), graph::lock, graph::modify, graph::pause_cond, graph::red_fire, graph::red_locked, graph::red_vertex_count, graph::remove_edges, graph::remove_vertices, SINGLE, graph::start, graph::state, TERMINATE, topologic_debug, and graph::vertices\&.
.PP
Referenced by cleanup(), and main()\&.
.SS "int destroy_request (struct \fBrequest\fP * request)"
@PARAM request: a request @RETURN -1 for fail; 0 for success Destroys and frees a request 
.PP
References request::args, request::f, request::request, and topologic_debug\&.
.PP
Referenced by destroy_graph_stack(), and test_destroy_request()\&.
.SS "int fire (struct \fBgraph\fP * graph, struct \fBvertex\fP * vertex, struct \fBvertex_result\fP * args, enum \fBSTATES\fP color, int iloop)"
@PARAM graph: the graph @PARAM vertex: A vertex to be ran @PARAM args: arguments @PARAM color: the state in which unlocks fire process if STATE is set to PRINT then fire will fail @PARAM iloop: the number of times that vertex fired in succession @RETURNS the result of the vertex fire will wake up the vertex and pass args to the vertex to compute its function and then call switch and clean itself up 
.PP
References edge::a_vars, fireable::args, edge::b, edge::b_vars, BI_EDGE, edge::bi_edge_lock, BLACK, graph::black_fire, graph::black_locked, graph::black_vertex_count, fireable::color, graph::context, destroy_stack(), vertex_result::edge_argv, vertex::edge_tree, edge::edge_type, vertex::f, edge::f, fire(), edge::glbl, vertex::glbl, fireable::iloop, init_stack(), vertex::is_active, graph::lock, vertex::lock, graph::max_loop, graph::max_state_changes, NONE, graph::num_vertices, pop(), preorder(), PTHREAD_SLEEP_TIME, RED, graph::red_fire, graph::red_locked, graph::red_vertex_count, vertex::shared, sleep_ms(), graph::state, graph::state_count, SWITCH, SWITCH_UNSAFE, switch_vertex(), TERMINATE, topologic_debug, vertex_result::vertex_argv, and shared_edge::vertex_data\&.
.PP
Referenced by fire(), and fire_pthread()\&.
.SS "void* fire_pthread (void * vargp)"
Wrapper function for fire, fire_1 @PARAM vargp: arguments 
.PP
References fireable::args, fireable::color, fire(), fireable::graph, fireable::iloop, PTHREAD_SLEEP_TIME, sleep_ms(), topologic_debug, and fireable::vertex\&.
.PP
Referenced by run(), and switch_vertex()\&.
.SS "struct \fBgraph\fP* graph_init (int max_state_changes, int snapshot_timestamp, int max_loop, unsigned int lvl_verbose, enum \fBCONTEXT\fP context, enum \fBMEM_OPTION\fP mem_option)"
@PARAM max_state_changes: # state changes before entering sink vertex due to infinite loop of states; -1 to ignore @PARAM snapshot_timestamp: printing out data at given timestamp for user; -1 for none; 0 for first and last state @PARAM lvl_verbose: how verbose timestamp print is @PARAM context: linear or context-switch based @RETURN an empty graph Creates a graph structures 
.PP
References graph::black_fire, graph::black_locked, graph::black_vertex_count, graph::color_lock, graph::context, destroy_avl(), destroy_stack(), init_avl(), init_stack(), graph::lock, graph::lvl_verbose, graph::max_loop, graph::max_state_changes, graph::mem_option, graph::modify, NONE, graph::num_vertices, graph::pause, graph::pause_cond, graph::previous_color, graph::print_flag, RED, graph::red_fire, graph::red_locked, graph::red_vertex_count, graph::remove_edges, graph::remove_vertices, SINGLE, graph::snapshot_timestamp, graph::start, graph::state, graph::state_count, topologic_debug, and graph::vertices\&.
.PP
Referenced by init()\&.
.SS "int modify_bi_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b, int(*)(void *, void *, const void *const, const void *const) f, void * glbl)"
@PARAM a: a vertex @PARAM b: another vertex @PARAM f: a function @PARAM glbl: global variables @RETURN 0 for success; -1 for fail; -2 if only edge from a to b is modified; -3 if only edge from b to a is modified Modifies the edge between a and b's function and variables NOTE: NULL f, or glbl will mean no change\&. 
.PP
References edge::a, edge::b, edge::f, edge::glbl, modify_edge(), and topologic_debug\&.
.PP
Referenced by procces_request(), and test_graph_modify_bi_edge()\&.
.SS "int modify_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b, int(*)(void *, void *, const void *const, const void *const) f, void * glbl)"
@PARAM a: a vertex @PARAM b: another vertex @PARAM f: a function @PARAM glbl: global variables @RETURN 0 for success; -1 for fail Modifies the edge connecting a to b's function NOTE: NULL f, or glbl will mean no change\&. 
.PP
References edge::a, edge::b, vertex::context, vertex::edge_tree, edge::f, find(), edge::glbl, vertex::id, vertex::lock, SINGLE, and topologic_debug\&.
.PP
Referenced by modify_bi_edge(), procces_request(), and test_graph_modify_edge()\&.
.SS "int modify_shared_edge_vars (struct \fBvertex\fP * vertex, void * edge_vars)"
@PARAM vertex: a vertex @PARAM edge_vars: shared variables @RETURN 0 for success; -1 for fail Modifies the vertices shared variables with it's edges 
.PP
References vertex::context, vertex::lock, vertex::shared, SINGLE, topologic_debug, and shared_edge::vertex_data\&.
.PP
Referenced by procces_request()\&.
.SS "int modify_vertex (struct \fBvertex\fP * vertex, void(*)(struct \fBgraph\fP *, struct \fBvertex_result\fP *, void *, void *) f, void * glbl)"
@PARAM vertex: a vertex @PARAM f: a function @PARAM glbl: global variables NOTE: NULL f, or glbl will mean no change\&. @RETURN 0 for success; -1 for fail Modifies the vertices function 
.PP
References vertex::context, vertex::f, vertex::glbl, vertex::lock, SINGLE, and topologic_debug\&.
.PP
Referenced by procces_request(), and test_graph_modify_vertex()\&.
.SS "struct \fBgraph\fP* parse_json (const char * path)"
@PARAM path: path to graph input file @RETURN the graph specified in the file 
.PP
Referenced by main()\&.
.SS "int pause_graph (struct \fBgraph\fP * graph)"
@PARAM graph: the graph @RETURN 0 for success -1 if it fails Pauses run 
.PP
References graph::lock, graph::pause, graph::pause_cond, and topologic_debug\&.
.SS "void print_graph (struct \fBgraph\fP * graph)"
@PARAM graph: the graph Prints the graph with desired output TODO: Print enums
.PP
References graph::context, graph::lock, graph::lvl_verbose, graph::max_loop, graph::max_state_changes, NO_VERB, graph::num_vertices, print_state(), SINGLE, AVLTree::size, graph::snapshot_timestamp, START_STOP, graph::state_count, topologic_debug, and graph::vertices\&.
.PP
Referenced by main(), run(), and run_single()\&.
.SS "int process_requests (struct \fBgraph\fP * graph)"
@PARAM graph: the graph @RETURN 0 if all got processed; -1 if a request failed will set ERRNO to the ENUM Process requests that are queued in the graph 
.PP
References graph::context, graph::lock, graph::modify, pop(), procces_request(), graph::remove_edges, graph::remove_vertices, SINGLE, and topologic_debug\&.
.PP
Referenced by init(), run(), run_single(), setupEdges(), setupSelfEdge(), setupVertex(), and test_process_requests()\&.
.SS "int remove_bi_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b)"
@PARAM a: a vertex @PARAM b: another vertex @RETURN 0 for success; -1 for fail; -2 if only edge from a to b is removed; -3 if only edge from b to a is removed Removes the edge connecting a to b 
.PP
References edge::a, edge::b, remove_edge(), and topologic_debug\&.
.PP
Referenced by procces_request(), and test_graph_remove_bi_edge()\&.
.SS "int remove_edge (struct \fBvertex\fP * a, struct \fBvertex\fP * b)"
@PARAM a: a vertex @PARAM b: another vertex @RETURN 0 for success; -1 for fail Removes the edge connecting a to b 
.PP
References edge::a, edge::a_vars, edge::b, edge::b_vars, BI_EDGE, edge::bi_edge, edge::bi_edge_lock, vertex::context, EDGE, vertex::edge_tree, edge::edge_type, edge::f, edge::glbl, edge::id, vertex::id, vertex::joining_vertices, vertex::lock, remove_ID(), SINGLE, and topologic_debug\&.
.PP
Referenced by cleanup(), create_bi_edge(), create_edge(), procces_request(), remove_bi_edge(), and test_graph_remove_edge()\&.
.SS "int remove_edge_id (struct \fBvertex\fP * a, int id)"
@PARAM a: a vertex @PARAM id: id of edge to remove @RETURN 0 for success; -1 for fail Removes the edge in a with that id 
.PP
References edge::a, edge::a_vars, edge::b, edge::b_vars, BI_EDGE, edge::bi_edge, edge::bi_edge_lock, vertex::context, EDGE, vertex::edge_tree, edge::edge_type, edge::f, edge::glbl, edge::id, vertex::id, vertex::joining_vertices, vertex::lock, remove_ID(), SINGLE, and topologic_debug\&.
.PP
Referenced by procces_request(), and remove_vertex()\&.
.SS "int remove_vertex (struct \fBgraph\fP * graph, struct \fBvertex\fP * vertex)"
@PARAM graph: the graph @PARAM vertex: a vertex @RETURN 0 for sucess; -1 for fail Removes the vertex and all connected edges 
.PP
References edge::a, edge::b, BI_EDGE, edge::bi_edge, edge::bi_edge_lock, graph::context, vertex::context, destroy_stack(), EDGE, vertex::edge_tree, edge::edge_type, edge::f, edge::glbl, vertex::glbl, edge::id, vertex::id, init_stack(), vertex::joining_vertices, graph::lock, vertex::lock, pop(), remove_edge_id(), remove_ID(), SELF_EDGE, vertex::shared, SINGLE, stackify(), topologic_debug, shared_edge::vertex_data, and graph::vertices\&.
.PP
Referenced by cleanup(), destroy_graph_avl(), procces_request(), remove_vertex_id(), and test_graph_remove_vertex()\&.
.SS "int remove_vertex_id (struct \fBgraph\fP * graph, int id)"
@PARAM graph: the graph @PARAM id: the vertex id @RETURN 0 for sucess; -1 for fail Removes the vertex and all connected edges 
.PP
References graph::context, find(), graph::lock, remove_vertex(), SINGLE, topologic_debug, and graph::vertices\&.
.PP
Referenced by procces_request()\&.
.SS "int resume_graph (struct \fBgraph\fP * graph)"
@PARAM graph: the graph @RETURN 0 for success -1 if it fails Resumes run 
.PP
References graph::lock, graph::pause, and topologic_debug\&.
.SS "int run (struct \fBgraph\fP * graph, struct \fBvertex_result\fP ** vertex_args)"
@PARAM graph: the graph @PARAM vertex_args: array of vertex arguments for f @RETURN 0 if run terminates normally -1 if it fails Attempts to run the graph else aborts\&. 
.PP
References ABORT, fireable::args, BLACK, graph::black_fire, graph::black_locked, graph::black_vertex_count, fireable::color, graph::color_lock, graph::context, CONTINUE, fire_pthread(), fireable::graph, fireable::iloop, vertex::is_active, graph::lock, MAX_ATTEMPTS, graph::max_state_changes, graph::mem_option, graph::num_vertices, graph::pause, graph::pause_cond, pop(), graph::previous_color, PRINT, graph::print_flag, print_graph(), process_requests(), RED, graph::red_fire, graph::red_locked, graph::red_vertex_count, run_single(), SINGLE, graph::start, graph::state, graph::state_count, TERMINATE, THREAD_ATTEMPT_SLEEP, topologic_debug, fireable::vertex, and WAIT\&.
.PP
Referenced by runTest(), test_run_none(), test_run_single(), and test_run_switch()\&.
.SS "int start_set (struct \fBgraph\fP * graph, int id[], int num_vertices)"
@PARAM graph: the graph, @PARAM id: the ids of the vertices @PARAM num_vertices: number of vertices @RETURN -1 for fail if any vertex fails; 0 for success Creates multiple contexts that are ran in parallel Handle errors
.PP
Given vertx failed, so at this point, free the vertices and leave
.PP
References graph::context, find(), vertex::id, pop(), push(), SINGLE, graph::start, topologic_debug, and graph::vertices\&.
.PP
Referenced by runTest(), setup_start_set(), and setupSelfEdge()\&.
.SS "int submit_request (struct \fBgraph\fP * graph, struct \fBrequest\fP * request)"
@PARAM graph: the graph @PARAM request: the request to be processed @RETRUN -1 for fail; 0 for succes; Submits a request to be processed after all active nodes complete 
.PP
References graph::context, DESTROY_BI_EDGE, DESTROY_EDGE, DESTROY_EDGE_BY_ID, DESTROY_VERTEX, DESTROY_VERTEX_BY_ID, graph::lock, graph::modify, push(), graph::remove_edges, graph::remove_vertices, request::request, SINGLE, and topologic_debug\&.
.PP
Referenced by init(), setEdge(), setupSelfEdge(), setupVertex(), test_submit_request(), and vertexFunction()\&.
.SS "int switch_vertex (struct \fBgraph\fP * graph, struct \fBvertex\fP * vertex, struct \fBvertex_result\fP * args, enum \fBSTATES\fP color, int iloop)"
@PARAM graph: the graph @PARAM vertex: The vertex in which just fire @PARAM args; The result of the vertex Upon call the switch function will compute the edge functions connected to the vertex @PARAM iloop: the number of times that vertex fired in succession @RETURNS 0 On success; the vertex connected to the successful edge will be fired; -1 on failure 
.PP
References ABORT, fireable::args, fireable::color, CONTINUE, vertex_result::edge_argv, vertex_result::edge_size, fire_pthread(), fireable::graph, fireable::iloop, MAX_ATTEMPTS, graph::mem_option, THREAD_ATTEMPT_SLEEP, topologic_debug, fireable::vertex, vertex_result::vertex_argv, vertex_result::vertex_size, and WAIT\&.
.PP
Referenced by fire()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Topologic from the source code\&.
